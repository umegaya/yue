package yue

import (
	"log"
	"time"
	"fmt"
	"sync"

	proto "github.com/umegaya/yue/proto"
)

//ExecuterFactory represents object can create Executer object
type ExecuterFactory interface {
	Create(uint64, ...interface{}) (Executer, error)
	Destroy(Executer)
}

//represents common rpc executer interface. 
type Executer interface {
	Call(string, ...interface{}) (interface {}, error)
}

//represent spawn configuration
type SpawnConfig struct {
	Factory ExecuterFactory
	args []interface{}
}



//represents process id. 
//it is generated by Node.NewUUID. you can resolve which node has this actor via nodes database of cockroachdb.
//ofcource, node may be restart and actually no actor exists on it, in that case, this node's seed is greater than
//timestamp part of processid, so caller node can return error.
type ProcessId proto.ProcessId

//represents process (worker of each actor)
type Process struct {
	Id proto.ProcessId
	sem sync.RWMutex
	Executer Executer //all executer methods called concurrenctly from multiple goroutine.
	conf *SpawnConfig
	owner *actor
	die bool
}

//create new process instance
func newprocess(owner *actor, conf *SpawnConfig) (*Process, error) {
	p := &Process {
		Id: proto.ProcessId(NewId()),
		conf: conf,
		sem: sync.RWMutex{},
		owner: owner,
	}
	go p.boot()
	return p, nil
}

//Call pass RPC argument to executer, restart if panic level error happen
//TODO: should we need the single thread mode? for example, prepare queue and every call() processed by single goroutine.
func (p *Process) call(method string, args ...interface{}) (r interface{}, err error, rs bool) {
	defer func() {
		p.sem.RUnlock()
        if e := recover(); e != nil {
            log.Println("call executer panics:", e)
            tmp, ok := e.(error)
            if ok {
            	err = tmp
            } else {
            	err = fmt.Errorf("%v", e)
            }
            r = nil
            rs = true
            amgr().restartq <- p
        }
    }()
    p.sem.RLock()
    if p.die {
    	//すでに死んでいる場合はもう復旧しないのでそういうエラーを返す.
		rs = false
    	err = newerr(ActorProcessGone, p.Id)
    	return
    }
    if p.Executer == nil {
    	rs = true //再起動中のはず.
    	return
    }
    r, err = p.Executer.Call(method, args...)
    rs = false
    return
}

//common process control
func (p *Process) control(stop bool) (err error) {
	defer func() {
        if e := recover(); e != nil {
            log.Println("create executer panics:", e)
            p.Executer = nil
            tmp, ok := e.(error)
            if ok {
            	err = tmp
            } else {
            	err = fmt.Errorf("%v", e)
            }
        }
		//死亡したことをマークしておく.(仮にdestroyに失敗していても)
        p.die = stop
	    p.sem.Unlock()
    }()
    p.sem.Lock()
    if p.Executer != nil {
		p.conf.Factory.Destroy(p.Executer)
		p.Executer = nil
	}
	if !stop {
		p.Executer, err = p.conf.Factory.Create(uint64(p.Id), p.conf.args...)
	}
	return
}

//start process
func (p *Process) start() error {
	return p.control(false)
}

//stop process
func (p *Process) stop() error {
	return p.control(true)
}

//boot process. repeatedly call start() while Executer is null.
func (p *Process) boot() {
	failure := 0
	for {
    	if p.Executer != nil {
    		break
    	} else if failure >= 10 {
    		log.Printf("too many failure %v", p.Id)
    		pmgr().kill(p.Id)
    		break
    	} else if err := p.start(); err != nil {
			log.Printf("start fails by %v", err)
			time.Sleep(100 * time.Millisecond)
			failure++
		} else {
			break
		}
	}
}


//processmgr represents processes which runs in this node
type processmgr struct {
	processes map[proto.ProcessId]*Process
	pmtx sync.RWMutex
}

func newprocessmgr() *processmgr {
	return &processmgr {
		processes: make(map[proto.ProcessId]*Process),
		pmtx: sync.RWMutex{},
	}
}

//sweep kill process which is remain idling in configured duration.
//assumed running by goroutine.
func (pm *processmgr) sweep(c *Config) {
	//TODO: check idle duration and kill.
	//but cost is not so low when process is provided by container.
}

//spawn creates process by using given factory
func (pm *processmgr) spawn(owner *actor, conf *SpawnConfig) (*Process, error) {
    p, err := newprocess(owner, conf)
    if err != nil {
    	log.Printf("spawn: %v", err)
    	return nil, err
    }
	defer pm.pmtx.Unlock()
	pm.pmtx.Lock()
	pm.processes[p.Id] = p
	log.Printf("spawn: %v", p.Id)
	return p, nil
}

//kill destroy process by using given factory.
func (pm *processmgr) kill(pid proto.ProcessId, opts ...interface{}) {
	pm.pmtx.Lock()
	p, ok := pm.processes[pid]
	if ok {
		delete(pm.processes, pid)
	}
	pm.pmtx.Unlock()
	if p != nil {
	    p.stop() //ignore error
	}
	log.Printf("kill: %v", pid)
}

//find finds process from pid
func (pm *processmgr) find(pid proto.ProcessId) (*Process, bool) {
	defer pm.pmtx.RUnlock()
	pm.pmtx.RLock()
	log.Printf("find: %v", pid)
	p, ok := pm.processes[pid]
	return p, ok
}
